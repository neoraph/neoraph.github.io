{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Raph Cheatsheet","text":"<p>I am using this small blog as a personal cheatsheets that might be interesting to other.</p>"},{"location":"Git/git/","title":"Git Tips","text":"<p>A bunch of useful commands for git (at least I find it usefull)</p>"},{"location":"Git/git/#use-different-account","title":"use different account","text":"<p>It happened that we have different git accounts which belong to different private keys (one account = one private key) and, on a same computer, we want to push to a repo from a specific account.  Here one way to achieve that.</p>"},{"location":"Git/git/#change-the-ssh-key-used-for-push","title":"Change the SSH key used for push","text":"<ul> <li>Run this one-off command in the repository that needs a different key. It stores the override inside <code>.git/config</code>.</li> </ul> <pre><code>git config core.sshCommand \"ssh -i &lt;path_to_private_key&gt; -o IdentitiesOnly=yes -F /dev/null\"\n</code></pre> <ul> <li>Replace <code>&lt;path_to_private_key&gt;</code> with the absolute path to the key you want to use (for example: <code>/Users/bob/.ssh/id_rsa_alt</code>).</li> <li>Git now reaches the remote using that key only for this repo, leaving other repositories untouched.</li> </ul>"},{"location":"Git/git/#safety-nets-when-things-break","title":"Safety nets when things break","text":"<ul> <li><code>git reflog</code> lists every commit your HEAD touched, even the ones no longer in the branch history. Use it whenever you lose track of a commit.</li> <li>Found the commit you need? Create a rescue branch before doing anything risky:</li> </ul> <pre><code>git checkout -b rescue/&lt;topic&gt; &lt;commit_hash_from_reflog&gt;\n</code></pre> <ul> <li>Not sure what you are about to do will work? Drop a quick backup tag so you can return instantly:</li> </ul> <pre><code>git tag backup/$(date +%Y%m%d-%H%M) HEAD\n</code></pre> <ul> <li>After recovering, delete temporary rescue tags/branches once you are confident the history is safe.</li> </ul>"},{"location":"Git/git/#reorganize-commits","title":"Reorganize commits","text":"<ul> <li>Need to tweak the last commit? Amend it without creating a new one:</li> </ul> <pre><code>git commit --amend\n</code></pre> <ul> <li>Combine or reorder several recent commits with an interactive rebase. Pick the range you want to edit (here, the last three commits):</li> </ul> <pre><code>git rebase -i HEAD~3\n</code></pre> <pre><code>- Inside the editor, change `pick` to `reword`, `squash`, or `fixup` to adjust the history.\n- If you use `fixup`/`squash`, finish the rebase and Git will prompt you to edit the merged commit message.\n</code></pre> <ul> <li>Polishing commits stacked on top of new work? Mark quick fixes with <code>--fixup</code> so autosquash reorders them automatically:</li> </ul> <pre><code>git commit --fixup &lt;commit_hash&gt;\ngit rebase -i --autosquash &lt;base_branch&gt;\n</code></pre> <ul> <li>After rewriting history, force-push with care if the branch is already published:</li> </ul> <pre><code>git push --force-with-lease\n</code></pre>"},{"location":"Java/multiple_jdks_cert/","title":"Managing Jdks and Certificates efficiently","text":""},{"location":"Java/multiple_jdks_cert/#context","title":"Context","text":"<p>Usually, we need to add a certificate to the truststore in a company environment to be able to use the jdk access to the internet. Things start to get complicated when we start to have several jdks version, as the truststore is generally link to one jdk. </p> <p>Some people use tools like <code>sdkman!</code>, but I prefer to have a cleaner \"system-level\" feel. the best approach is to use a Global Version Manager combined with a Shared Truststore.</p>"},{"location":"Java/multiple_jdks_cert/#tldr","title":"TL;DR","text":""},{"location":"Java/multiple_jdks_cert/#1-version-management-jenv","title":"1. Version Management: jEnv","text":"<p>It simply manages the JDKs you already have.</p> <ul> <li> <p>Install: <code>brew install jenv</code></p> </li> <li> <p>Add: <code>jenv add /path/to/jdk_folder</code></p> </li> <li> <p>Use: <code>jenv global 21</code> or <code>jenv local 17</code> (per project).</p> </li> </ul> <p>Vital: Enable the export plugin to keep your <code>$JAVA_HOME</code> in sync: <code>jenv enable-plugin export</code></p>"},{"location":"Java/multiple_jdks_cert/#2-the-certificate-fix-global-truststore","title":"2. The Certificate Fix: Global Truststore","text":"<p>Stop modifying every new JDK. Force Java to use one single certificate file for the whole system.</p> <p>Setup: Copy an existing <code>cacerts</code> file to <code>~/.java/security/global-cacerts</code>.</p> <p>Import: Add your 3<sup>rd</sup> party certs once to this file.</p> <p>Activate: Add this to your .zshrc or .bashrc: <pre><code>export JAVA_TOOL_OPTIONS=\"-Djavax.net.ssl.trustStore=$HOME/.java/security/global-cacerts -Djavax.net.ssl.trustStorePassword=changeit\"\n</code></pre></p>"},{"location":"Java/multiple_jdks_cert/#3-intellij-configuration","title":"3. IntelliJ Configuration","text":"<p>JDKs: Go to File &gt; Project Structure and add the JDKs located in ~/.jenv/versions/.</p> <p>Automation: IntelliJ will inherit your JAVA_TOOL_OPTIONS from your shell, so your certificates will work instantly in the IDE without per-project configuration.</p> <p>In short: jEnv handles the paths, and JAVA_TOOL_OPTIONS handles the security centrally.</p>"},{"location":"Java/multiple_jdks_cert/#1-managing-different-jdks","title":"1. Managing different JDKs","text":""},{"location":"Java/multiple_jdks_cert/#the-best-tool-jenv-and-asdf","title":"The Best Tool: jenv and asdf","text":"<p>If SDKMAN felt too \"intrusive\" or messy, asdf is the industry standard for managing multiple runtimes (Java, Node, Python, etc.) via a single tool.</p>"},{"location":"Java/multiple_jdks_cert/#jenv-for-macoslinux","title":"jenv (for macOS/Linux):","text":"<p>If you like to download JDKs manually (from Oracle, Azul, etc.) and just want a way to switch JAVA_HOME easily, use jEnv. You just \"add\" your existing JDK paths to it, and it manages the switching.</p>"},{"location":"Java/multiple_jdks_cert/#using-asdf","title":"using asdf","text":"<p>It uses a simple <code>.tool-versions</code> file in your project folders to switch versions automatically when you cd into them.</p>"},{"location":"Java/multiple_jdks_cert/#installation","title":"Installation:","text":"<ul> <li>Install asdf via their official guide.</li> <li>Add the Java plugin: asdf plugin add java.</li> <li>Install a version: asdf install java openjdk-21.</li> </ul> <p>Set it globally: <code>asdf global java openjdk-21</code>.</p>"},{"location":"Java/multiple_jdks_cert/#2-managing-certificates","title":"2. Managing certificates","text":""},{"location":"Java/multiple_jdks_cert/#solving-the-certificate-annoyance","title":"Solving the \"Certificate Annoyance\"","text":"<p>The reason you have to re-configure certificates is that every JDK comes with its own cacerts file located inside its installation folder. When you switch JDKs, you switch to a \"blank\" truststore.</p> <p>The \"One Truststore to Rule Them All\" Strategy Instead of importing certificates into every JDK, create one Global Truststore and tell all your JDKs to use it.</p> <p>Create a central truststore: Copy the cacerts file from one of your JDKs to a permanent location, e.g., <code>~/.java/global-cacerts</code>.</p>"},{"location":"Java/multiple_jdks_cert/#import-your-certificates-once","title":"Import your certificates once:","text":"<pre><code>keytool -import -trustcacerts -keystore ~/.java/global-cacerts -storepass changeit -alias my-api -file my_cert.crt\n</code></pre> <p>You can also just copy the cacert that you create on a specific jdk to this place (don't need to renegerate it).</p> <pre><code>cp /path/to/your/current/working/truststore ~/.java/global-cacerts\n</code></pre>"},{"location":"Java/multiple_jdks_cert/#if-your-password-is-not-changeit-update-this","title":"If your password is NOT 'changeit', update this:","text":"<p>export JAVA_TOOL_OPTIONS=\"-Djavax.net.ssl.trustStore=$HOME/.java/security/global-cacerts -Djavax.net.ssl.trustStorePassword=YOUR_PASSWORD\"</p>"},{"location":"Java/multiple_jdks_cert/#merging-vs-replacing","title":"Merging vs. Replacing","text":"<p>If your existing file is a full cacerts copy: (meaning it has your private certs plus the standard internet ones like DigiCert/Verisign), then you are good to go.</p> <p>If your existing file ONLY contains your private certs: You might run into issues connecting to standard websites (like Maven Central or GitHub) because the \"official\" root certificates are missing.</p> <p>How to verify what's inside: </p> <p>Run this command to see how many certificates are in your file:  <pre><code>keytool -list -keystore ~/.java/security/global-cacerts -storepass yourpassword | grep \"Your keystore contains\"\n</code></pre></p> <ul> <li> <p>~100+ certs: It\u2019s a full bundle (Safe to use as-is).</p> </li> <li> <p>1-5 certs: It\u2019s a private-only store. In this case, you should import your certs into a fresh copy of the system cacerts instead.</p> </li> </ul> <p>Point all Java processes to it: Add this environment variable to your <code>.zshrc</code> or <code>.bashrc</code>:</p> <pre><code>export JAVA_TOOL_OPTIONS=\"-Djavax.net.ssl.trustStore=$HOME/.java/global-cacerts -Djavax.net.ssl.trustStorePassword=changeit\"\n</code></pre> <p>Result : No matter which JDK you switch to (via asdf, jEnv, or even IntelliJ), the JVM will automatically pick up your custom certificates from that one file.</p> <p>Why this is better for jEnv Since jenv works by changing your PATH and JAVA_HOME, it doesn't actually change your shell environment variables like JAVA_TOOL_OPTIONS.</p> <p>By pointing to this single file, you bypass the \"Java 11 has its own certs, Java 21 has its own certs\" problem entirely.</p> <p>Every version managed by jenv will wake up, read that specific file, and \"just work.\"</p>"},{"location":"Java/multiple_jdks_cert/#3-connecting-intellij-to-this-setup","title":"3. Connecting IntelliJ to this Setup","text":"<p>Since you don't like IntelliJ's internal management, you can point it to use your system-managed JDKs:</p> <p>Go to File &gt; Project Structure &gt; SDKs.</p> <p>Click + and select Add JDK....</p> <p>Point it to the directory where asdf or your manual install keeps the JDKs (usually ~/.asdf/installs/java/...).</p> <p>Because you set the JAVA_TOOL_OPTIONS globally in your shell profile, IntelliJ will usually inherit that setting if you launch it from the terminal or have configured your OS environment variables correctly.</p>"},{"location":"crypto/address_algo/","title":"Major cryptocurrency Address Formats and Key Features","text":"Coin/Blockchain Version Name Account/Address Model Address Format Address Prefix/Example Key Features / Notes Bitcoin (BTC) Native SegWit (P2WPKH) UTXO-Based Bech32 (BIP 173) Starts with bc1q Lowest fees, native SegWit. Bitcoin (BTC) Taproot UTXO-Based Bech32m (BIP 350) Starts with bc1p Enhanced privacy, most modern format. Ethereum (ETH) Standard Account-Based Hexadecimal Starts with 0x Used for ETH and all ERC-20 tokens. Cardano (ADA) Shelley (New) Hybrid (UTXO-Like) Bech32 (Custom) Starts with addr1 Supports staking and multi-asset capabilities. Cardano (ADA) Byron (Legacy) UTXO-Based Base58Check Starts with Ae2 or DdzFF Older, less feature-rich format. Solana (SOL) Standard Account-Based Base58 (Custom) No specific prefix (32\u201344 chars) Stores everything (code, data, tokens) as accounts. Case-sensitive. XRP (XRP) Classic Account-Based Base58Check (XRP variant) Starts with r Requires a Destination Tag for exchange deposits. XRP (XRP) X-Address Account-Based Base58Check (XRP variant) Starts with X Combines the classic address and the Destination Tag into one string. Polkadot (DOT) Standard Account-Based SS58 (Base58 variant) No single prefix (varies by network) Unified address format across the Polkadot ecosystem (Parachains). NEAR Named Account Account-Based Human-Readable e.g., alice.near Domain-name-like, easy-to-read addresses. NEAR Implicit Account Account-Based Hexadecimal 64 characters long Derived directly from the public key."},{"location":"crypto/address_algo/#utxo-vs-account-model","title":"UTXO vs Account Model","text":"<p>UTXO (Unspent Transaction Output) Model: Used by Bitcoin, Litecoin, Dogecoin, etc. Funds are stored as discrete \"outputs\" which are consumed entirely and new outputs are created (like physical cash). This is where Script Types (P2PKH, P2SH, P2WPKH) are essential for locking/unlocking the funds.</p> <p>Account Model: Used by Ethereum. Funds are stored in a single balance for each address, and transactions modify that balance (like a bank account). This is why there are no complex script types in the same way, as the address itself is the destination.</p>"},{"location":"crypto/address_algo/#encoding-scheme","title":"Encoding Scheme","text":"<p>Base58Check: The traditional encoding for older addresses (starts with 1, 3, L, D, etc.). It's case-sensitive and omits confusing characters (like 0, O, I, l).</p> <p>Bech32 / Bech32m (BIP 173/350): The modern, native SegWit encoding (starts with bc1q, bc1p, ltc1q). It is case-insensitive (only uses lowercase), offers better error detection, and is slightly more space-efficient</p>"},{"location":"crypto/address_algo/#explaining-the-different-script-types-utxo-model","title":"Explaining the Different Script Types (UTXO Model)","text":"<p>For coins like Bitcoin and Litecoin that use the UTXO (Unspent Transaction Output) Model, the \"script type\" is the rule set written on the blockchain that determines how a coin can be spent.</p>"},{"location":"crypto/address_algo/#p2pkh-pay-to-public-key-hash","title":"P2PKH (Pay-to-Public-Key-Hash)","text":"<p>The Rule: To unlock the funds, the spender must provide a Public Key and a valid Signature that proves they own the corresponding Private Key.</p> <p>Analogy: A simple lockbox where the key holder's name (the public key hash) is on the outside, and you just need to open it with the right key (the private key/signature).</p> <p>Address: Starts with 1 (Bitcoin Legacy).</p>"},{"location":"crypto/address_algo/#p2sh-pay-to-script-hash","title":"P2SH (Pay-to-Script-Hash)","text":"<p>The Rule: To unlock the funds, the spender must provide a Script that hashes to the value locked in the output, AND they must provide the Signature(s) that successfully run that script.</p> <p>Analogy: A more complex lockbox with an internal combination lock. You don't see the combination (the full script) until you open the first lock, but you need to know the combination to successfully open the box.</p> <p>Address: Starts with 3 (Bitcoin Legacy/Nested SegWit). This is commonly used for multi-signature wallets (e.g., \"2-of-3\") or to nest a SegWit script (P2SH-P2WPKH), which is how Nested SegWit works.</p>"},{"location":"crypto/address_algo/#p2wpkh-pay-to-witness-public-key-hash","title":"P2WPKH (Pay-to-Witness-Public-Key-Hash)","text":"<p>The Rule: Same rule as P2PKH (Public Key + Signature), but the data (the \"witness\") is moved to a separate part of the transaction block (the \"witness\" data).</p> <p>Analogy: The lockbox is opened just like P2PKH, but the transaction record itself is lighter because the signature/public key data is stored in an optional, discounted area of the block.</p> <p>Address: Starts with bc1q (Native SegWit/Bech32).</p>"},{"location":"crypto/address_algo/#the-core-concept-locking-not-sending","title":"The Core Concept: Locking, Not Sending","text":"<p>In Bitcoin, you don't actually send a currency amount to an address. Instead, you create a new transaction output that is locked with a specific Script (the rule set) and points to a previous, unspent output (UTXO).</p>"},{"location":"crypto/address_algo/#1-how-funds-are-locked-the-locking-script-scriptpubkey","title":"1. How Funds Are Locked (The Locking Script: scriptPubKey)","text":"<p>When a Bitcoin user wants to \"send\" money, they are actually creating a new transaction output (UTXO) on the blockchain. This output contains two main parts:Value: The amount of Bitcoin being transferred.Locking Script (scriptPubKey): This is the puzzle or the set of conditions that must be satisfied to spend the funds. This script specifies the necessary public key hash (or a more complex script hash) that the spender must prove ownership of. Analogy: The scriptPubKey is like a safe deposit box on the blockchain with a required combination (the public key hash) written on the outside. Only the person who knows the combination (the private key) can create the key to open it.For a standard P2PKH (Legacy) transaction, the scriptPubKey essentially says:\"To spend this money, you must provide a valid Signature AND a Public Key that hashes to this specific Public Key Hash.\"</p>"},{"location":"crypto/address_algo/#2-how-funds-are-unlocked-the-unlocking-script-scriptsig","title":"2. How Funds Are Unlocked (The Unlocking Script: scriptSig)","text":"<p>To \"receive\" and then spend the money, the new spender (the \"receiver\" from the previous transaction) creates a new transaction input that references that specific locked output (the UTXO).</p> <p>The input must contain the Unlocking Script (scriptSig) which provides the solution to the locking script's puzzle. scriptSig (The Solution): This script contains two key pieces of data:</p> <p>The Signature: Created by the spender's Private Key over the details of the new transaction. This proves ownership. The Public Key: The public key corresponding to the private key used for the signature.</p> <p>Verification (The Execution): The Bitcoin network's nodes take the two scripts\u2014the scriptSig (Solution) and the scriptPubKey (Puzzle)\u2014and run them together in order through the Bitcoin Script virtual machine (stack-based language).</p> <p>The scriptSig pushes the signature and public key onto the stack.</p> <p>The scriptPubKey uses these items to perform cryptographic checks (like hashing the public key and verifying the signature).</p> <p>Success Condition: If the combined script executes successfully (meaning it returns a value of \"True\"), the output is unlocked, and the funds can be spent in the new transaction. Example of P2PKH Script Flow (Simplified)Here's a step-by-step look at what happens when the two scripts are run:StepScript ExecutingActionResult on StackInput (scriptSig)[Signature]Pushes the signature onto the stack. [Signature]Input (scriptSig)[Public Key]Pushes the public key onto the stack. [Signature], [Public Key]Output (scriptPubKey)OP_DUPDuplicates the Public Key. [Sig], [PK], [PK]Output (scriptPubKey)OP_HASH160Hashes the top Public Key. [Sig], [PK], [PK_Hash]Output (scriptPubKey)[PK Hash (Target)]Pushes the original required hash. [Sig], [PK], [PK_Hash], [PK_Hash (Target)]Output (scriptPubKey)OP_EQUALVERIFYCompares the two hashes. If not equal, script fails. [Signature], [Public Key] (if successful)Output (scriptPubKey)OP_CHECKSIGUses the Signature and Public Key to verify the transaction details. If successful, returns TRUE. [TRUE]If the script returns TRUE, the transaction is valid, and the funds are unlocked!The SegWit Difference (P2WPKH)For Native SegWit (P2WPKH), the process is the same, but the Signature and Public Key (the Witness data) are stored in the separate, cheaper-to-send witness field of the transaction, rather than the scriptSig.  This is what gives SegWit its fee reduction benefit.</p>"}]}